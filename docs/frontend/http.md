# HTTP

## 1. 从输入url到展示页面的全过程

1. URL解析

   * 协议+ip+端口+路径+参数+锚点

   <img src=".\img\url解析.png" style="zoom: 67%;" />

2. DNS查询，获取ip

   * 先访问本地host文件、然后是本地域名服务器、根服务器、....
   * 过程中涉及递归查询和迭代查询
   * 目的是获取ip地址

3. 建立TCP连接

   * TCP三次握手，TCP面向连接的协议

4. 发送HTTP请求

   * 请求行、请求头、请求体
   * 请求行包括：请求方式、请求地址和http协议及版本

5. 拿到HTTP响应结果

   * 状态行、响应头、响应体

6. 渲染页面

   * 解析HTML，构建DOM树
   * 解析CSS，建立CSS规则树
   * 合并DOM树和css规则树，生成render树
   * 布局render树，负责各元素的尺寸和位置的计算
   * 绘制render树，绘制页面像素信息
   * 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上

## 2. TCP三次握手/四次挥手

* **三次握手：**为了使客户端和服务端建立可靠连接，确保客户端和服务端的发送和接收能力均是正常的。
  1. 第一次握手：客户端发送SYN报文，并指明客户端的初始序列号ISN，
  2. 第二次握手：服务端接收SYN报文，发送自己的SYN报文给客户端，并将客户端的ISN+1作为ACK的值，发给客户端
  3. 第三次握手：客户端接收SYN报文，然后发送ACK报文，ACK的值为服务端的ISN+ 1。此时客户端处于Establish状态，服务端接收到报文后，也会处于Establish状态
* **为什么不适用二次握手？**
  * 因为只握手两次的话，服务端没办法确认客户端的接收能力
* **四次挥手：**
  1. 第一次挥手：客户端发送FIN报文，报文中有自己的ISN
  2. 第二次挥手：服务端接收客户端的FIN报文，给客户端发送ACK报文，ack的值为客户端的ISN+1.告诉客户端自己收到了FIN报文
  3. 第三次挥手：（需要等到服务端的报文发送完毕），服务端给客户端发送FIN报文，自己的ISN
  4. 第四次挥手：客户端收到FIN报文后，发送ACK报文作为应答，ack的值为服务端报文的ISN+ 1。此时客户端处于TIME-WATI状态，需过一段时间确保服务端收到自己的ACK报文后才会进入closed状态。服务端收到ACK报文后就立马处于closed状态
* **为什么要四次挥手？**
  * 服务端接收到客户端的断开连接的FIN报文后，并不会立刻断开连接，而是先发一个ACK报文告诉客户端收到关闭连接的请求。等到服务器所有的报文发送完毕之后，才发送FIN报文断开连接。

## 3. 进程和线程的区别

* **资源占用：**进程是操作系统分配资源的基本单位，线程是进程中的一个执行单元，每个进程拥有独立的地址空间和系统资源。一个进程内可以有多个线程，线程共享进程内的内存
* **系统调度**：操作系统通过调度进程控制块来管理和调度进程。线程由进程创建和销毁，不由操作系统直接调度
* **开销的区别**

## 5. HTTP协议及各个版本号

（HTTP1.0是短链接，一次连接请求成功，完成发送和接收数据成功后，就断开了连接，这样建立连接的消耗比较大。所以在HTTP1.0的基础上，HTTP1.1使用了长连接，在一个TCP连接上可以传送多个HTTP请求和响应，HTTP2.0在1.0的版本上，增加了多路复用，就是1.1中HTTP请求是由顺序的，下一个http请求必须等到前一个请求结束后，才可以发送。多路复用就是指HTTP请求是并行发送的，除了多路复用，http2.0还增加了头部压缩，使用二进制的解析方式替代http1.0中的字符串的解析方式，解决了解析上的缺陷。还有就是服务端推送，）

1. Http1.0：tcp是短链接，连接成功使用后，就断开连接（每次建立连接需要花费时间，造成延迟）
2. HTTP1.1：长连接：一个TCP连接上可以传送多个HTTP请求和响应
3. HTTP2.0：长连接+多路复用
   * **多路复用**：在一个TCP连接上，多个HTTP请求可以并行发送（在HTTP1.1中http请求必须等上一个请求完成后，才能发送）
   * **header压缩**：HTTP1.x中的头部带有大量的信息，每次都要重复发送。HTTP2.0使用encoder减少需要传输的header的大小，通讯双方各自cache一份header fields表，**既避免了重复header的传输**，又**减小了需要传输的大小。**（HTTP2.0可以维护一个字典，差量更新HTTP头部）
   * **服务端推送：**服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。服务端可以主动发起一些数据推送。比如，服务端在接收到浏览器发来的 `HTML` 请求的同时，可以主动推送相关的资源文件（js/css）给客户端，并行发送，提高网页的传输和渲染效率。
   * `HTTP1.x` 的解析是基于文本，存在解析上的缺陷；而 `HTTP2.0` 直接使用**二进制的解析方式**来替代 `HTTP 1.X` 的字符串解析，更为高效和健壮。
4. HTTP性能优化：
   * 合理使用 `HTTP` 的缓存策略，避免同一资源多次请求服务端而导致的额外性能开销
   * 尽量使用 `HTTP` 长连接，避免每次重建 `TCP` 连接带来的时间损耗
   * 尽量使用 `HTTPS` 来保证网络传输的安全性。
   * 可以使用 `HTTP2` 来大幅提高数据传输的效率，使用 `server push` 开启 `HTTP2` 的服务端推送功能
   * 客户端开启 `Accept-Encoding` 压缩方式的支持，服务端传输压缩后的文件，减少传输数据的大小
5. HTTP和HTTPS
   * 加密：Https相比于http，增加了SSL加密解密数据的过程。http明文传输
   * **端口**：http端口是80，https端口是443
   * **防劫持**
   * **证书**：https需要服务器端使用数字证书，证书由受信任的证书颁发机构CA签名

## 5. IPv4和IPv6

* IPv4由四部分组成，每部分是一个字节，8位，可表示的范围是0到255。总共四个字节

  * 正则表达式：先匹配前面三个数，范围0到255之间，并且有点号。最后一个数0到255之间，结尾\
  * 匹配0到255之间的数：可以分为几部分
    * 200到255之间：`2[0-5][0-5]`
    * 100到199：`1\d\d`
    * 10到99： `[1-9]\d`
    * 0到9： `\d`

  ```js
  ^(((2[0-5][0-5] | 1\d\d | [1-9]\d | \d ).){3})()$
  ```

* IPv6由八部分组成，每部分由4个16进制组成，一个16进制需用4位来表示，4个16进制需要2个字节。所以IPv6由16个字节组成

  * 正则表达式：IPv6前面0可以省略，

  ```js
  ^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$
  ```

  
