# HTTP

## 1. 从输入url到展示页面的全过程

1. URL解析

   * 协议+ip+端口+路径+参数+锚点

   <img src=".\img\url解析.png" style="zoom: 67%;" />

2. DNS查询，获取ip

   * 先访问本地host文件、然后是本地域名服务器、根服务器、....
   * 过程中涉及递归查询和迭代查询
   * 目的是获取ip地址

3. 建立TCP连接

   * TCP三次握手，TCP面向连接的协议

4. 发送HTTP请求

   * 请求行、请求头、请求体
   * 请求行包括：请求方式、请求地址和http协议及版本

5. 拿到HTTP响应结果

   * 状态行、响应头、响应体

6. 渲染页面

   * 解析HTML，构建DOM树
   * 解析CSS，建立CSS规则树
   * 合并DOM树和css规则树，生成render树
   * 布局render树，负责各元素的尺寸和位置的计算
   * 绘制render树，绘制页面像素信息
   * 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上

## 2. TCP三次握手/四次挥手

* **三次握手：**为了使客户端和服务端建立可靠连接，确保客户端和服务端的发送和接收能力均是正常的。
  1. 第一次握手：客户端发送SYN报文，并指明客户端的初始序列号ISN，
  2. 第二次握手：服务端接收SYN报文，发送自己的SYN报文给客户端，并将客户端的ISN+1作为ACK的值，发给客户端
  3. 第三次握手：客户端接收SYN报文，然后发送ACK报文，ACK的值为服务端的ISN+ 1。此时客户端处于Establish状态，服务端接收到报文后，也会处于Establish状态
* **为什么不适用二次握手？**
  * 因为只握手两次的话，服务端没办法确认客户端的接收能力
* **四次挥手：**
  1. 第一次挥手：客户端发送FIN报文，报文中有自己的ISN
  2. 第二次挥手：服务端接收客户端的FIN报文，给客户端发送ACK报文，ack的值为客户端的ISN+1.告诉客户端自己收到了FIN报文
  3. 第三次挥手：（需要等到服务端的报文发送完毕），服务端给客户端发送FIN报文，自己的ISN
  4. 第四次挥手：客户端收到FIN报文后，发送ACK报文作为应答，ack的值为服务端报文的ISN+ 1。此时客户端处于TIME-WATI状态，需过一段时间确保服务端收到自己的ACK报文后才会进入closed状态。服务端收到ACK报文后就立马处于closed状态
* **为什么要四次挥手？**
  * 服务端接收到客户端的断开连接的FIN报文后，并不会立刻断开连接，而是先发一个ACK报文告诉客户端收到关闭连接的请求。等到服务器所有的报文发送完毕之后，才发送FIN报文断开连接。