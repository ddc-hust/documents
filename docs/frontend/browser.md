# 浏览器

## 2. 页面渲染流程阻塞问题

从首次发出url请求到页面展示过程中可以分为3个阶段：

1. 第一个阶段：等请求发出去之后，到提交数据这个阶段，这个阶段，页面展示的还是之前的内容（拼接url，查缓存，DNS请求查IP，TCP连接建立， HTTP请求, http响应（http响应码的判断，如果是301和302需要重定向））
2. 第二个阶段：提交数据之后，渲染进程创建一个空白的页面，等待css文件和js文件加载执行完成， 生成CSSOM、DOM，然后合成布局树，分层、栅格化、绘制
3. 第三个阶段：首次渲染完成之后，就进入完成页面的生成阶段，页面将会被一点一点的生成出来

**思考：**首屏时间就是从页面拿到HTML字节流之后，开始渲染的过程。那么这个过程中浏览器的任务主要是下载CSS文件、下载JS文件以及执行js脚本。所以要想缩短白屏的时间考虑从以下几个方面入手：

1. 内联css和内联js，这样就可以省去下载的时间，但是不是所有所有场合都适合用内联
2. 对于需要下载的文件，可以考虑使用webpack打包工具 ，移除不必要的注释，压缩js文件的大小
3. 对于不需要操作dom的js脚本，考虑放在文档末尾，或者使用async和defer异步加载执行
4. 对于大的css文件，通过媒体查询属性，将其拆分为多个用途的css文件，再特定的场景下加载特定的css文件。

1. js脚本问题
   * js脚本会阻塞dom的加载，从而阻塞页面的渲染。
   * 可以使用cdn来加速js文件的加载
   * 压缩js文件的体积
   * 如果js脚本中没有操作dom的相关代码，可以把该js脚本设置为异步加载。async：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞HTML解析，执行时机在load事件派发之前 defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前
2. css样式加载的问题
   * css样式不会阻塞dom的加载，但是会阻塞js脚本的执行，因为js脚本中可能会操作css，所以在脚本执行之前，需要加载完该脚本之前的css文件，所以css会阻塞js脚本的执行，而js脚本会阻塞页面的渲染，所以css也有可能会间接的阻塞页面的渲染
   * 如果把css放在文档最后加载执行，这样的话，css就不会阻塞dom的加载，也不会阻塞js的加载和执行，浏览器会在解析完dom后，再解析css。这样效果不好，会先出现一个没有样式的页面，再闪动出现一个有样式的页面。所以css文件需要放在头部，尽可能的提前加载css。把js放在文档尾部，使得js不会阻塞页面的渲染。
3. 缩短首屏时长（白屏）
   * 内联css，内联js脚本，移除文件下载的消耗，使得浏览器获取到HTML后就直接开始渲染流程
   * 使用webpack打包工具移除不必要的注释，压缩js文件
   * 异步加载
   * 对于大的css文件，使用媒体查询属性，将其分为多个用途的css文件。

### 页面首次渲染VS页面渲染

* 图片、音频、视频等文件不会阻塞页面的首次渲染
* 但是JS文件、css文件、首次请求的HTML资源文件会阻塞页面的首次渲染。（需要明白页面的首次渲染：从浏览器拿到HTML文件，开始解析HTML文件，构建DOM树开始到有内容显示的过程），这个过程中构建DOM树，js文件、css文件以及请求的HTML资源文件都会阻塞DOM树的构建（css间接阻塞），在domContentloaded之前，这些文件就加载执行好了。页面有内容渲染出来。然后才是加载图片、视频等文件，这些文件在loaded事件之前执行完毕。（注意这里的JS文件和css文件的请求是通过预解析线程同步下载的）
* 阻塞页面首次渲染的资源成为关键资源（css， js, html资源文件）
* 关键资源的多少、大小以及关键资源需要多少个RTT（Round Trip Time）都是影响页面的首次渲染的
  * 减少关键的个数：可以通过内联css、js文件就可以减少关键资源个数。或者对于不操作DOM的js，可以放在文档末尾或者异步加载。对于css可以使用媒体属性，阻止加载
  * 减少关键的大小：压缩CSS和JAVASCRIPT文件，移除注释内容
  * 减少RTT：使用CDN减少每次的RTT时长

### 交互阶段的性能优化

* 交互阶段优化的核心原则是尽量减少一帧的生成时间
  1. 减少单次javascript的执行时间
  2. 避免强制同步布局，强制同步布局就是在执行js的过程中又去访问布局的信息，这样会导致在执行js的过程中去刷新布局（计算样式和布局都是在当前脚本执行过程中触发的）
  3. 避免布局抖动：在一次javascript执行过程中，多次执行强制布局
  4. 合理利用CSS合成动画，css合成动画是在合成线程上执行的，不会占用主线程
  5. 避免频繁的垃圾回收，执行垃圾回收的时候会占用主线程，从而影响其它任务的执行

### 重绘VS重排vs合成

* 重绘：改动页面元素的样式等，这些不涉及布局的重新计算，布局树的操作可以跳过，直接进行绘制
* 重排：改动页面的布局，布局树需要重新计算，开销较大
* 合成：在合成线程上操作，比如css的动画

---

* **js脚本会阻塞页面的渲染**，浏览器从上到下解析html文档并渲染，遇到`js`脚本，会将渲染线程挂起，以去执行`js`脚本。
  * 所以为了防止页面加载`js`脚本被阻塞，导致网站出现大量的空白时间。可以采用异步加载js脚本的技术。
    * 具体方法是使用`defer`和`async`。使得在浏览器解析html和渲染的同时，能够加载js脚本。因为使用`defer`和`async`，主线程会异步加载，继续解析html，`async`会在异步加载完成之后，会立即执行。`defer`会在html解析完成之后立即执行。
  * 也可以采用将js脚本放在html文档底部。这样它会在在HTTP请求的所有其他组件之后加载并执行，并且渲染过程将不会被阻塞。
  * 或者压缩和合并js文件的大小。减小文件大小，以加快文件下载和执行速度
* **使用link标签引入css文件**，遇到css文件的时候，**并不会阻塞**浏览器解析html的。因为通过标签引入的css文件是异步加载和解析的，它不会阻塞dom树的构建，但是由于css毕竟是样式文件，它会影响页面的渲染，所以如果外部css过大，会影响页面的加载速度。
* **使用内联样式**：内联样式**会影响浏览器解析html**的，因为浏览器从上到下依次加载，必须解析完内联样式，才能继续解析下面的内容，虽然内联样式减少了http请求数，如果内联样式非常复杂或者过多，可能会显著影响页面的加载性能，导致页面加载速度变慢。

---

* DOMContentLoaded: 当页面的内容解析完成后，则触发该事件    •JS 会阻塞DOM的解析和渲染，所以DOMContentLoaded会在JS执行后触发   • 因为CSS会阻塞JS执行       • 如果JS在CSS之前或只有CSS资源，则DOMContentLoaded事件不必等CSS加载完毕       • 如果页面同时存在JS和CSS且CSS在JS之前，那DOMContentLoaded事件需等待CSS加载完毕后触发 

* onLoad: 等待页面的所有资源都加载完成才会触发，这些资源包括css、js、图片视频等

## 3. WebComponent

* 三个组成要素：自定义元素、影子DOM、HTML模板
* 影子DOM：将模板中的内容与全局DOM和全局CSS进行隔离，实现元素和样式的私有化

## 4. 虚拟DOM

* 批量更新DOM，有使用到双缓存的设计（注意是批量更新DOM，那么批量更新的时间就比较重要，vue中批量更新的时间是下一次事件循环之前，本次事件循环包括同步任务、宏任务、微任务。微任务队列执行完毕，会进入执行宏任务,此时就开始了下一次事件循环）
* 虚拟DOM 并没有解决js频繁操作DOM引起的性能问题，因为虚拟DOM并没有减少操作（存疑，万一对一个节点重复操作，虚拟DOM应该是可以去重的吧？）

## 5. 浏览器中JS执行机制

### 1. 变量提升

* JS是先编译再执行。在编译阶段创建执行上下文
  * 编译阶段：会把变量的声明以及函数的声明提升到代码头部，本质并没有改动代码的位置，不过是在变量环境中存储了变量的声明以及函数的声明。变量的赋值会默认为`undefined`
  * 执行阶段：执行相应的赋值操作，从变量环境中查找赋值的变量以及函数。这个时候比如函数的声明就不会再执行了。

### 2. 执行上下文vs调用栈

* 执行全局代码的时候，创建全局执行上下文，全局执行上下文中包含变量环境和词法环境等。
* 调用函数的时候，创建函数执行上下文，
* 所以会出现多个执行上下文，JS中使用调用栈来管理执行上下文

### 3. 词法环境vs变量环境

* 执行上下文中包含词法环境和变量环境。var声明的变量存在变量提升，会被放在变量环境中。let和const声明的变量不存在变量提升，会被放在词法环境中，虽然不存在变量提升，但在词法环境中会提升变量的创建，但是不会初始化，这里是区别去var的，var提升了变量的创建，并初始化为undefined。let和const不会初始化，所以如果在let初始化之前访问的话，会报错`“Uncaught ReferenceError: Cannot access 'myname' before initialization”`，且let和const是块级作用域，块级作用域内的变量，外面是访问不到的。这是通过在词法环境中实现类似执行栈的结构来实现的。

* 块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了

* 在块作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区

  ```js
  let myname= '极客时间'
  {
    console.log(myname) 
    let myname= '极客邦'
  }
  ```

## 4. 词法作用域

* 词法作用域：作用域由代码中函数声明的位置来决定的。词法作用域是静态作用域
* 词法作用域是代码编译阶段就决定好的，和函数怎么调用没有关系
* js执行过程中，作用域链由词法作用域来决定。

## 5. 页面加载时间戳

1. `navigationStart`：导航开始
   - 表示页面导航（比如 URL 地址变化）开始的时间点。它标记了整个页面加载过程的起点。
2. `fetchStart`：资源请求开始
   - 表示浏览器开始获取页面的所有资源（比如 HTML、CSS、JavaScript 文件等）的时间点。
3. `domainLookupStart` 和 `domainLookupEnd`：域名解析
   - `domainLookupStart`：表示域名解析开始的时间点。
   - `domainLookupEnd`：表示域名解析结束的时间点。在这个阶段，浏览器正在查询 DNS 来获取服务器的 IP 地址。
4. `connectStart` 和 `connectEnd`：建立连接
   - `connectStart`：表示与服务器建立连接的开始时间点。
   - `connectEnd`：表示与服务器建立连接的结束时间点。在这个阶段，浏览器正在建立与服务器的网络连接。
5. `secureConnectionStart`：安全连接建立
   - 表示安全连接（HTTPS）开始建立的时间点。
6. `requestStart` 和 `responseStart`：请求和响应
   - `requestStart`：表示浏览器开始向服务器发送请求的时间点。
   - `responseStart`：表示服务器开始返回响应的时间点。
7. `responseEnd`：响应结束
   - 表示服务器完成响应并将数据传输给浏览器的时间点。
8. `domLoading` 和 `domInteractive`：DOM 加载
   - `domLoading`：表示浏览器开始解析页面的时间点，创建 DOM 树。
   - `domInteractive`：表示浏览器完成解析页面的时间点，DOM 树已经构建完毕。在这个阶段，浏览器已经可以访问页面的 DOM 元素。
9. `domContentLoadedEventStart` 和 `domContentLoadedEventEnd`：DOMContentLoaded 事件
   - `domContentLoadedEventStart`：表示DOMContentLoaded 事件开始的时间点。在这个阶段，页面的 DOM 已经完全构建，但可能还有一些外部资源（如样式表、图像）仍在加载。
   - `domContentLoadedEventEnd`：表示DOMContentLoaded 事件结束的时间点。在这个阶段，页面的 DOM 已经完全构建，所有与 DOMContentLoaded 事件相关的处理已经完成。
10. `domComplete`：DOM 完成
    - 表示浏览器完成构建完整的 DOM 树的时间点。在这个阶段，页面的 DOM 已经包含了所有的 HTML 元素和其它相关的资源。
11. `loadEventStart` 和 `loadEventEnd`：页面加载事件
    - `loadEventStart`：表示页面加载事件开始的时间点。在这个阶段，浏览器开始执行页面的 `load` 事件处理程序。
    - `loadEventEnd`：表示页面加载事件结束的时间点。在这个阶段，页面的 `load` 事件处理程序已经执行完毕，所有资源（包括图像、样式表、脚本等）都已加载完成。

### 1. domcontentloadedEventStart和loadEventStart

* 第一个表示：dom树构建完毕，但有一些外部资源在加载，所以需要加载外部资源
* 第二个表示：页面及所有资源都加载完成，然后浏览器开始执行load事件（注意这个阶段不是再去加载资源，而是去执行load事件）。`load` 事件是在页面及其所有外部资源（如图像、样式表、脚本等）都已加载完成后触发的。
* load事件处理程序是表示页面及所有的资源都已经加载完毕后，再执行的操作。可用于初始化应用程序和组件、显示加载完成的提示动画等。

## 6. 从输入url到页面的加载过程

* 可以分为导航和渲染两部分。导航部分就是从输入url到浏览器拿到html文档。渲染部分就是对html文档进行解析，到页面渲染出内容。
* 整个过程会涉及到浏览器进程、网络进程、和渲染进程之间的交互
* 在导航部分，
  * 首页浏览器进程会处理用户输入的url，
  * 接着浏览器进程通过进程间的通信将url发送给网络进程。
  * 网络进程先会在本地缓存中查看是否缓存了资源，如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。
  * 网络请求首先会进行DNS解析， dns解析首先会
  * 建立TCP链接
  * tcp连接建立好之后，会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息
  * 服务端也会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息）发给网络进程
  * 网络进程接收到响应数据后，开始解析，不同的状态码会有不同的操作。如果是301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，
  * 这个时候，网络进程接收到响应数据了。网络进程就会通知浏览器进程，浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
  * 渲染进程和网络进程建立数据管道；开始准备接收 HTML 数据
  * 浏览器进程就会更新浏览器进程中的页面状态。
  * （这就是用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。）
* 在渲染部分
  * 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
  * 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
  * 创建布局树，并计算元素的布局信息。
  * 对布局树进行分层，并生成分层树。
  * 为每个图层生成绘制列表，并将其提交到合成线程。
  * 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
  * 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
  * 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

## 7. Http请求报文、响应报文

1. **请求报文**：
   1. `Cache-Control`：指定对缓存的控制方式。例如，`Cache-Control: no-cache` 表示不使用缓存，每次都从服务器获取最新的响应。
   2. `Content-Type`：指定请求正文的媒体类型。例如，`Content-Type: application/json` 表示请求正文是 JSON 数据。
   3. `Accept`：指定客户端可以接受的响应内容类型。例如，`Accept: text/html` 表示客户端希望接收 HTML 类型的响应。
   4. `Cookie`：包含了与请求相关的 Cookie 信息。当服务器需要识别客户端状态时，客户端可以将之前收到的 Cookie 值通过该头部字段发送回服务器。
   5. `Authorization`：用于在请求中发送身份验证凭据，通常用于访问受保护的资源。例如，`Authorization: Bearer token123` 表示请求附带了一个访问令牌进行身份验证。
   6. `If-None-Match`：用于缓存验证，值为ETag，ETag用于标识和验证资源的版本。服务端接收到这个字段后，会和当前资源的ETag进行比较，从而返回304(直接用缓存)，或者200
   7. `If-Modified-Since`：用于条件性请求，表示只有自指定日期后资源被修改过才返回响应。服务器可以使用该头部字段来进行缓存验证。
2. **响应报文**
   1. 状态行、响应头部和响应主体。
   2. 响应头部（Response Headers）：响应头部包含了与响应相关的元数据信息。一些常见的响应头字段包括：
      - Date：响应生成的日期和时间。
      - Server：指示响应的服务器软件信息。
      - Content-Type：指定响应主体内容的类型和字符集。
      - Content-Length：指示响应主体内容的长度。
      - Cache-Control：指定缓存策略，如 max-age、no-cache 等。
      - Expires：指定响应过期的日期和时间。
      - Last-Modified：指示资源的最后修改时间。
      - ETag：指定资源的唯一标识符。

## 8. 强缓存、协商缓存

* **强缓存：**在初始请求时，需要发送请求。然后把响应头中的缓存字段，比如expires或者cache-control缓存在本地，后续请求时，查询本地之前缓存的响应头的字段，如果没有过期，就不用重新发起请求，直接使用本地的资源就可以。否则需要重新发起请求

  * 在初次请求时获取资源，并在资源未过期时直接使用本地缓存，避免再次向服务器发送请求。只有当资源过期或缓存失效时，客户端才需要发送请求到服务器进行缓存验证或获取新的资源副本。
  * 常用的强缓存相关的响应头字段有以下两个：
    - **Expires**：指定资源的过期时间，是一个具体的日期时间。客户端在过期时间之前可以直接使用本地缓存。但是该字段存在一些问题，如时间是相对于服务器时间，如果客户端和服务器的时间不一致，可能会导致缓存失效。
    - **Cache-Control：**指定缓存策略的各种指令。常见的指令有：
      - max-age：指定资源的最大缓存时间，以秒为单位。
      - public：表示资源可以被任意缓存（包括客户端和代理服务器）缓存。
      - private：表示资源只能被客户端缓存，不能被代理服务器缓存。
      - no-cache：表示客户端要使用缓存，但在使用之前必须与服务器确认资源是否发生变化。
      - no-store：表示不允许缓存，每次请求都要向服务器发送请求。
    - **也就是说，如果是强缓存的，响应头中会有expires过期时间以及cache-control缓存策略字段**
  * #### Cache-Control: no-cache 和no-store的区别

    `Cache-Control: no-cache`：这个很容易让人产生误解，使人误以为是响应不被缓存

    实际上`Cache-Control: no-cache`是会被缓存的，只不过浏览器每次都会向服务器发起请求，来验证当前缓存的有效性

    `Cache-Control: no-store`：这个才是响应不被缓存的意思

* **协商缓存**：需要做客户端和服务端的交互。

  * 协商缓存是通过在请求头和响应头之间进行交互，判断资源是否发生变化，并决定是否使用本地缓存或请求服务器。常用的协商缓存相关的请求头和响应头字段有以下两组：

    - 请求头字段：
      - **If-Modified-Since**：指示服务器只在资源的最后修改时间（Last-Modified）比该字段值新时才返回资源，否则返回 304 Not Modified 响应。
      - **If-None-Match：**指示服务器只在资源的 ETag 值与该字段值不匹配时才返回资源，否则返回 304 Not Modified 响应。
    - 响应头字段：
      - **Last-Modified：**指定资源的最后修改时间，用于和客户端的 If-Modified-Since 进行比较。
      - **ETag：**指定资源的唯一标识符，用于和客户端的 If-None-Match 进行比较。

  * 当客户端发起请求时，如果强缓存失效，客户端会发送带有协商缓存字段的请求，与服务器协商确定是否使用缓存。服务器会根据请求头中的条件和资源的状态进行比较，然后返回相应的响应状态码，告知客户端是否可以使用本地缓存。

  * 协商缓存的流程

    * **第一次请求**

       1、客户端发送GET请求，去请求文件；
       2、服务器处理请求，返回文件内容和一堆Header，包括Etag，状态码200

    * **第二次请求**

      1、客户端发起 HTTP GET 请求一个文件，注意这个时候客户端请求头上，会带上`if-none-match值为Etag`和`if-modified-since值为last-modified`

      2、服务器优先判断Etag和计算出来的Etag匹配，若匹配status状态为`304`，客户端继续使用本地缓存
  

## 9. cookie

* **cookie:** http是无状态的协议，为了让服务器可以区分不同的客户端，可以通过cookie维护这个状态，cookie是在客户端保存的一段文本信息，可以包含一些用户的信息。当用户第一次访问网站的时候，服务器会生成一个cookie并通过响应头set-cookie字段发送给客户端，客户端在本地保存这个cookie，当用户再次访问网站时，浏览器将这个携带用户信息的cookie作为请求体中，发送给服务端。这样服务端就可以知道用户信息了。实现了有状态。
  * 浏览器本地存储的 Cookie 是基于域名的，每个网站都有自己的 Cookie 存储空间，不同域名之间的 Cookie 是相互隔离的。
* **session:** session是服务端的技术，用于管理和跟踪用户会话的状态。**所以session是保存在服务端进程中的，关闭服务端进程，seesion就无法获取了**。当用户第一次访问网站时，服务器会为该用户创建一个Session对象，生成一个Session ID，并将Session ID保存到Cookie中发送给客户端。客户端在之后的每一次请求中都会携带该Session ID，服务器通过Session ID可以找到对应的Session对象，从而识别用户身份、保存用户状态等。
* **Token:** token是一个令牌，使用token实现登录鉴权时，服务器端虽然可以不用去数据库或内存中取用户信息，只需要对这个token进行解密即可，但是解密的过程会消耗性能。
  * Access Token： 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活；
    Refresh Token： 用来获取 Access Token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 Session 一样处理；

## 10. JWT

* 使用cookie需要将用户信息存在cookie中，会有信息泄露的风险。
* 使用session的话，服务端需要维护seesion，开销较大

* JWT由头部、载荷和签名组成。头部包括JWT的类型和签名算法等信息。载荷包含了用户的身份信息和其它附加数据。签名由头部、载荷、密钥以及签名算法组成。用于验证jwt的完整性和真实性。

* **JWT防篡改：**JWT 的签名部分会使用到 header 和 payload，以及一个 **secret 私钥**，这个私钥只有服务端才知道，所以我们可以利用这个特性，来防止 token 被篡改。就算客户端拿到了 token，也无法伪造一个新的 token，因为它不知道 secret 私钥是什么，也就没有办法生成一个新的签名。

* **JWT退出登录态**：由于token生成后就是永久有效的，如何设置token的失效呢？

  * 在payload中设置过期时间：
  * 服务端白名单：存储token有效的列表
  * 服务端黑名单：存储token注销的列表

## 11. localStorage\SessionStorage

* localStorage和sessionStorage的区别
  * 都用于在客户端（浏览器）中存储数据，以便在不同的页面和会话之间保持数据的持久性。
  * 主要区别：
    * **数据的生命周期：**localStorage中存储的数据没有过期时间，除非被显式删除，否则将一直存在于客户端。而sessionStorage中存储的数据只在当前会话（session）期间有效。当用户关闭浏览器标签或窗口时，sessionStorage中的数据将被清除。
    * **数据共享范围：**localStorage中存储的数据在同一个域名下的所有页面之间共享，即使是在不同的窗口或标签中打开也可以访问。而sessionStorage中存储的数据仅在同一个窗口或标签页中共享，不同窗口或标签页之间的数据是隔离的。
    * localStorage适合用于需要在不同页面和会话之间保持持久性数据的场景，而sessionStorage适合用于在单个会话期间临时存储数据的场景。

## 12. 浏览器和Node的事件循环

* **进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位**
* 以 Chrome 浏览器中为例**，当你打开一个 Tab 页时，其实就是创建了一个进程，**一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

### 	1. 浏览器的事件循环

* 宏任务是一个一个执行的，微任务是一队一队执行的
* **当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。**

### 	2. node.js的事件循环/nexttick

* node.js的事件循环分阶段执行。

  * timer阶段: 执行 timer（setTimeout、setInterval）的回调

  * io callback阶段: 处理一些上一轮循环中的少数未执行的 I/O 回调

  * idle.prepar阶段

  * poll阶段: 获取新的 I/O 事件, 适当的条件下 node 将阻塞在这里

    * 回到timer阶段执行回调，（如果有timer，并且timer超时了）

    * 执行IO回调

    * 如果没有timer

      * 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制

      * 如果 poll 队列为空时，会有两件事发生

      * - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
        - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去

  * check阶段: 执行 setImmediate() 的回调

  * close callback阶段: 执行 socket 的 close 事件回调

* **process.nextTick**

  * 这个是有单独的队列的，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。
  * `process.nextTick` 用于 Node.js 中，在事件循环的微任务队列中执行回调函数。将一个回调函数添加到当前事件循环的微任务队列中，并确保在当前事件循环的末尾立即执行。与 `setTimeout` 不同，`process.nextTick` 的回调函数将在当前事件循环的其他任务之前执行，包括 Promise 的微任务回调函数、`setImmediate` 回调函数等。这使得 `process.nextTick` 具有较高的执行优先级，通常用于确保回调函数在当前操作完成后立即执行。ssssss
  * 而 `this.$nextTick` 用于 Vue.js 中，在 Vue 组件的上下文中，用于在 DOM 更新之后执行回调函数。执行时机是在下一个事件循环周期的微任务队列中

### 	3. 区别

  * 浏览器中，微任务队列是在执行完一个宏任务后就执行的

  * node.js中，微任务队列是在各阶段之间执行的。

  * ```js
    setTimeout(()=>{
        console.log('timer1')
        Promise.resolve().then(function() {
            console.log('promise1')
        })
    }, 0)
    setTimeout(()=>{
        console.log('timer2')
        Promise.resolve().then(function() {
            console.log('promise2')
        })
    }, 0)
    //浏览器的输出： timer1 promise1 timer2 promise2
    // node的输出： timer1 timer2 promise1 pomise2
    ```

		* 

## 13. 如何优化资源加载速度？

* 
  优化资源加载速度是提高网站性能和用户体验的关键方面。以下是一些常见的方法和技巧，可以帮助您优化资源加载速度：
  1. **使用内容分发网络（CDN）：** 使用CDN可以将您的静态资源（如样式表、脚本和图像）分发到位于世界各地的服务器上，从而加速资源的加载。CDN通常具有高速、可靠的服务器，可以减少延迟并提高响应时间。
  2. **压缩资源：** 压缩静态资源（如CSS和JavaScript文件）以减小文件大小。可以使用工具如Gzip和Brotli来压缩资源文件。压缩后的文件需要更少的带宽，加载速度更快。
  3. **合并文件：** 将多个小文件合并为一个大文件，减少HTTP请求数量。这对于CSS和JavaScript文件特别有效。但请注意，不要过度合并，以免影响可维护性。
  4. **使用异步加载：** 使用`async`和`defer`属性来异步加载JavaScript文件，以防止它们阻止页面的渲染。`async`和`defer`的区别在于加载和执行的顺序。
  5. **优化图片：** 使用适当的图像格式（如WebP），以及压缩和缩小图像以减小文件大小。还可以使用图片懒加载技术，仅在用户滚动到视口时加载图像。
  6. **延迟加载非关键资源：** 将非关键资源（如广告、社交媒体插件等）的加载延迟到页面的主要内容已经加载完毕后。这可以加速首次页面渲染。
  7. **使用浏览器缓存：** 设置合适的缓存策略，利用浏览器缓存来减少服务器请求。设置合适的缓存头部，如`Cache-Control`和`Expires`。
  8. **减少重定向：** 避免过多的重定向，因为每次重定向都会增加加载时间。
  9. **使用HTTP/2协议：** HTTP/2支持多路复用，可以同时发送多个请求，减少了资源加载的延迟。
  10. **代码优化：** 优化前端代码，包括删除不必要的代码、减少DOM操作、避免同步HTTP请求等。

## 14. css会阻塞页面的渲染吗？

* 分为内联样式和link样式
  * 内联样式：由于js从上到下依次执行，所以是会存在一定影响的。（不过内联样式减少了http请求数）
  * link样式：异步加载，不会阻塞页面的渲染。（但是如果js中有使用到css的话，就会相当于间接影响）
