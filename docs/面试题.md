# HTML

# CSS

# JS

## 1. 模块化规范

* node采用的是common.js模块化规范，使用`require`和`module.exports`，缺点：只能同步加载，无法异步加载（所以浏览器使用的是ES6模块化规范）
* es6模块化规范：使用`import`和`export`导入和导出。（浏览器和服务端node都支持，）优点：可异步加载，

# vue

## 1. MVVM模式



# node

## 1. node.js是什么？有什么特点？

* node.js是js运行时的环境

* 事件循环、非阻塞IO、可处理高并发、异步编程、模块化、可跨平台、单线程

* ```markdown
  Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，可用于开发服务器端应用程序。它是一个轻量级的、高效的、事件驱动的、非阻塞I/O模型的平台。Node.js可以运行在多种操作系统上，例如Windows、Mac OS X、Linux等。
  
  Node.js的特点包括：
  
  高效性：Node.js采用事件驱动、非阻塞I/O模型，能够处理大量的并发连接，且具有较高的I/O吞吐量和较低的延迟。
  
  跨平台性：Node.js可以在多个操作系统上运行，并且具有很好的可移植性。
  
  模块化：Node.js采用模块化的设计，可以方便地管理和复用代码。
  
  生态系统：Node.js拥有庞大的生态系统，提供了大量的第三方模块和工具，可以帮助开发者快速构建应用程序。
  
  单线程：Node.js采用单线程的设计，可以避免多线程之间的竞争和同步问题，简化了开发和调试的难度。
  
  异步编程：Node.js的异步编程模型可以使得程序的执行不会被I/O操作所阻塞，从而提高了应用程序的响应速度和并发性能。
  
  总的来说，Node.js具有高效、跨平台、模块化、生态系统丰富、单线程、异步编程等特点，适用于开发高性能、高并发、可扩展的服务器端应用程序。
  ```

## 2. 什么是模块？Node.js 如何实现模块化？

* 模块可被其它模块引用，代码封装，提高复用
* Node.js使用CommonJS规范实现模块化，开发者可以使用exports对象或module.exports对象将模块的功能暴露出去，然后使用require()函数引用这些模块。

## 3. Node.js 如何处理文件和目录？

在Node.js中，可以使用fs模块来处理文件和目录。fs模块提供了一系列的API，可以对文件和目录进行读取、写入、删除、修改等操作。

以下是一些常见的文件和目录操作：

1. 读取文件内容：可以使用fs.readFile()函数来读取文件的内容。该函数的参数包括文件路径和回调函数，在回调函数中可以获取文件内容或错误信息。

```js
javascriptCopy codeconst fs = require('fs');

fs.readFile('file.txt', function (err, data) {
  if (err) throw err;
  console.log(data.toString());
});
```

1. 写入文件内容：可以使用fs.writeFile()函数来写入文件的内容。该函数的参数包括文件路径、写入内容和回调函数，在回调函数中可以获取写入状态或错误信息。

```js
javascriptCopy codeconst fs = require('fs');

fs.writeFile('file.txt', 'Hello, Node.js!', function (err) {
  if (err) throw err;
  console.log('File saved!');
});
```

1. 创建目录：可以使用fs.mkdir()函数来创建一个新目录。该函数的参数包括目录路径、目录权限和回调函数，在回调函数中可以获取创建状态或错误信息。

```js
javascriptCopy codeconst fs = require('fs');

fs.mkdir('newdir', function (err) {
  if (err) throw err;
  console.log('Directory created!');
});
```

1. 读取目录内容：可以使用fs.readdir()函数来读取目录的内容。该函数的参数包括目录路径和回调函数，在回调函数中可以获取目录内容或错误信息。

```js
javascriptCopy codeconst fs = require('fs');

fs.readdir('somedir', function (err, files) {
  if (err) throw err;
  console.log(files);
});
```

1. 删除文件或目录：可以使用fs.unlink()函数删除文件，使用fs.rmdir()函数删除目录。这两个函数的参数都是要删除的路径和回调函数，在回调函数中可以获取删除状态或错误信息。

```js
javascriptCopy codeconst fs = require('fs');

fs.unlink('file.txt', function (err) {
  if (err) throw err;
  console.log('File deleted!');
});

fs.rmdir('somedir', function (err) {
  if (err) throw err;
  console.log('Directory deleted!');
});
```

总的来说，使用fs模块可以方便地进行文件和目录的读写、创建、删除等操作。开发者可以根据自己的需求选择适合的API进行使用。

# webpack

## 1. webpack是什么？作用是什么？

>（是什么？）静态模块打包器，
>
>（有什么用？怎么做的？）用于将代码、图片等资源文件打包在一个或多个js中，通过静态分析解决多个js模块之间的依赖关系，并把他们打包在一个文件中。（提供loader解析非js文件，plugin用于优化代码）。
>
>（特点？）支持热替换HMR，无需刷新页面即可更新模块；支持代码分割和懒加载，优化加载速度。，处理css、图片、字体等静态资源

Webpack 是一个现代 JavaScript 应用程序的静态模块打包器。Webpack 可以将代码、图片、样式等静态资源视为模块，通过 loader 和 plugin 将它们转换为可在浏览器中运行的静态资源。

Webpack 的主要作用是打包 JavaScript 应用程序，并将多个 JavaScript 模块和其它资源打包成一个或多个 JavaScript 文件。它可以通过静态分析来解决多个 JavaScript 模块之间的依赖关系，并将它们打包到一个文件中。同时，Webpack 还可以处理 ES6/ES7、TypeScript、React、Vue 等框架的代码。

除了打包 JavaScript 应用程序，Webpack 还提供了许多功能，例如：

1. 处理 CSS、图片、字体等静态资源。
2. 支持代码分割和懒加载，优化应用程序的加载速度。
3. 支持热模块替换（HMR），实现在应用程序运行时无需刷新页面即可更新模块。
4. 提供了丰富的插件和 loader，可以对打包过程进行自定义配置。

总的来说，Webpack 是一个强大的打包工具，它可以让开发者更加高效地开发和维护 JavaScript 应用程序，并提供了许多有用的功能和工具，帮助开发者更好地管理和优化代码。

## 2. Webpack 的核心概念是什么？请详细解释每个概念的作用和使用方式。

> entry、output、loader（转化非js文件）、plugin（扩展webpack功能，在不同阶段触发钩子函数）、mode(开发模式、生成模式)、resolve(处理符合解析模块)

1. Entry：入口

Entry 是指 Webpack 构建时的入口文件，Webpack 会从入口文件开始分析模块依赖，然后进行打包。一个项目可以有多个入口文件，也可以使用动态导入和异步加载模块实现动态的入口。

```
javascriptCopy codemodule.exports = {
  entry: './src/index.js'
};
```

1. Output：输出

Output 是指 Webpack 打包后的输出文件，可以是一个或多个 JavaScript 文件，也可以是其他静态资源文件。Output 可以通过 filename 属性来指定输出文件名，通过 path 属

network error

出目录。

```js
javascriptCopy codemodule.exports = {
  output: {
    filename: '[name].[contenthash].js',
    path: path.resolve(__dirname, 'dist')
  }
};
```

1. Loader：加载器

Loader 是用于处理 Webpack 打包过程中遇到的非 JavaScript 文件（如 CSS、图片、字体等）的工具。每个 Loader 可以将对应类型的文件转换成 JavaScript 模块，使得 Webpack 可以对其进行打包和处理。Loader 需要在 module.rules 中配置，并且按照规则从后向前执行。

```js
javascriptCopy codemodule.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        type: 'asset/resource'
      }
    ]
  }
};
```

1. Plugin：插件

Plugin 是用于扩展 Webpack 功能的工具。每个 Plugin 都是一个 JavaScript 对象，包含 apply 方法，该方法在 Webpack 运行的不同阶段触发相应的钩子函数，可以用于执行自定义任务，如打包前清除输出目录、提取 CSS 到单独的文件等。Plugin 需要在 plugins 中配置。

```js
javascriptCopy codeconst { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
  plugins: [
    new CleanWebpackPlugin(),
    new HtmlWebpackPlugin({
      title: 'Webpack Demo'
    })
  ]
};
```

1. Mode：模式

Mode 是用于指定 Webpack 运行模式的选项，分为 development、production 和 none 三种模式，它会自动启用不同的内置插件和优化策略。开发模式（development）下，启用开发工具、调试信息等，生产模式（production）下，启用代码压缩、优化等。

```js
javascriptCopy codemodule.exports = {
  mode: 'production'
};
```

1. Resolve：解析

Resolve 用于指定 Webpack 如何解析模块，如查找模块的目录、使用的文件扩展名、别名等。通过配置 resolve.alias 可以为模块路径指定别名，避免模块路径过长。

```js
javascriptCopy codemodule.exports = {
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  }
};
```

这些概念是 Webpack 的核心，掌握了这些概念，就可以更好地理解 Webpack 的工作原理，进行自定义配置和优化。

## 3. loader

> style-loader：使用link标签引入csss文件，将css文件注入到html页面的style标签中
>
> css-loader
>
> sass-loader
>
> vue-loader：处理vue.js单文件组件，将其转换成js模块，包括编译模板、解析组件等
>
> babel-loader：es6z转es5
>
> json-loader：处理json文件，
>
> url-loader/file-loader：处理图片、字体等静态资源文件

## 4. Plugin

> htmlWebpackPlugin：自动生成html文件，把打包后的bundle.js文件自动注入到html中
>
> HotMoudleReplacementPlugin：实现热更新，在代码修改后不用刷新也可以看到修改的效果
>
> CleanWebpackPlugin：在打包之前清空打包目录，避免之前打包的文件影响到现在的打包结果

1. HtmlWebpackPlugin：用于自动生成 HTML 文件，并将打包后的 bundle.js 文件自动注入到 HTML 中，支持多页面应用程序的打包。
2. MiniCssExtractPlugin：用于将 CSS 文件从 JavaScript 中提取出来，生成单独的 CSS 文件，使得代码更加简洁清晰。
3. CleanWebpackPlugin：用于在打包之前清空打包目录，避免之前的打包文件影响到当前的打包结果。
4. UglifyJsPlugin：用于压缩 JavaScript 代码，减小文件大小，提升应用程序的性能。
5. CopyWebpackPlugin：用于将静态文件复制到打包目录中，例如图片、字体等文件。
6. DefinePlugin：用于定义全局变量，在代码中可以直接使用，例如定义 NODE_ENV 变量，用于判断当前应用程序的运行环境。
7. BundleAnalyzerPlugin：用于分析打包后的代码，生成可视化的报告，帮助开发者了解应用程序中各个模块的体积大小以及依赖关系等信息，从而优化打包结果。
8. HotModuleReplacementPlugin：用于实现热更新，使得在开发过程中代码修改后不需要刷新浏览器即可看到修改的效果。

## 4. 如何在 Webpack 中实现代码分割（Code Splitting）？请说明 Code Splitting 的作用和实现方式

## 5. 如何在 Webpack 中优化性能？请列举几种常见的性能优化方法。

> 代码分割、tree shaking、压缩插件、懒加载、

1. 代码分割：通过使用动态导入和代码分割，可以将应用程序分割成较小的代码块。这有助于减少打包文件的大小和初始加载时间。在使用动态导入和代码分割时，确保你只导入需要的代码，而不是整个库或模块。
2. Tree Shaking：通过使用 Tree Shaking 技术，可以删除不需要的代码，从而减少打包文件的大小。Tree Shaking 是一个代码优化技术，可以通过使用 ES6 模块语法和 UglifyJS 等工具来实现。
3. Scope Hoisting：Scope Hoisting 是一个新特性，可以将多个作用域中的代码合并成一个，从而减少了在运行时的闭包代码数量，提高了代码的运行性能。Webpack 4 默认开启了 Scope Hoisting。
4. 懒加载：通过使用懒加载技术，可以在需要时再加载代码，而不是在初始加载时就加载全部代码。这有助于减少初始加载时间和打包文件的大小。React.lazy 和 Suspense 是 React 中的一种懒加载方式。
5. 使用 Webpack 插件：Webpack 提供了许多插件，用于优化代码的运行性能，例如 UglifyJS 插件可以压缩代码、CommonsChunkPlugin 插件可以提取公共代码、ProvidePlugin 可以自动加载模块等。
6. 代码优化：优化代码本身可以提高代码的运行性能。例如，避免不必要的循环、使用更高效的算法、避免全局变量等。
7. 多进程打包：使用 thread-loader、parallel-webpack 等工具可以实现多进程打包，提高打包速度。
8. 使用缓存：使用缓存可以减少打包时间，可以使用 cache-loader、hard-source-webpack-plugin 等工具实现缓存功能。

## 6. 如何在 Webpack 中实现按需加载（Lazy Loading）？请说明按需加载的作用和实现方式。

> 提高加载速度，动态导入、react.lay, vue的异步组件

按需加载（Lazy Loading）是一种优化 Webpack 打包后的代码体积和加载性能的技术。它的主要作用是将不必要的代码暂时不加载，等到需要使用时再进行加载，从而减少页面首次加载的时间和提升用户体验。

在 Webpack 中，可以通过以下几种方式实现按需加载：

1. 使用动态导入

动态导入是一种将代码块按需加载的方式，可以在代码运行时根据需要加载特定的代码块，从而实现按需加载。

```js
javascriptCopy codeimport('./module').then(module => {
  // Use module
});
```

这种方式可以根据需要加载代码块，实现按需加载，但是需要手动编写异步加载代码，不够方便。

1. 使用 React.lazy

React.lazy 是一个 React 内置的代码分割方案，可以实现按需加载组件，从而提高页面加载性能。

```js
javascriptCopy codeconst OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <OtherComponent />
    </div>
  );
}
```

这种方式可以方便地实现按需加载组件，但是需要使用 React 框架。

1. 使用 Vue 的异步组件

Vue 提供了一种异步组件的方式，可以实现按需加载组件，从而提高页面加载性能。

```js
javascriptCopy code
Vue.component('async-component', () => import('./AsyncComponent.vue'))
```

这种方式可以方便地实现按需加载组件，但是需要使用 Vue 框架。

按需加载可以在减少页面首次加载的时间的同时，也可以减小文件大小，提高代码复用性和缓存性能。但是需要根据具体场景选择适当的实现方式，并进行合理的优化配置。

## 6. 如何在 Webpack 中处理图片和字体文件？请列举几种常用的处理方式并说明它们的作用。

> file-loader：将图片和字体等文件转换成url
>
> url-loader：在一定的大小范围内，把图片和字体等文件转成base64格式内嵌到代码中。超过该范围，就使用转成url

在 Webpack 中处理图片和字体文件可以通过使用 Loader 进行处理，以下是几种常用的处理方式：

1. file-loader

file-loader 可以处理文件的打包和导出，可以将图片和字体等文件转换为一个 URL，以便在应用程序中使用。

使用方式：

```js
javascriptCopy codemodule: {
  rules: [
    {
      test: /\.(png|jpe?g|gif|svg|eot|ttf|woff|woff2)$/,
      loader: 'file-loader',
      options: {
        name: '[name].[ext]',
        outputPath: 'assets',
      },
    },
  ],
},
```

在配置中，test 表示需要处理的文件类型，name 表示输出文件的名称，outputPath 表示输出文件的路径。

1. url-loader

url-loader 与 file-loader 类似，也可以处理图片和字体等文件，但是可以根据文件大小自动判断使用 file-loader 还是将文件转换为 base64 格式并内联到代码中。

使用方式：

```js
javascriptCopy codemodule: {
  rules: [
    {
      test: /\.(png|jpe?g|gif|svg|eot|ttf|woff|woff2)$/,
      loader: 'url-loader',
      options: {
        limit: 8192,
        name: '[name].[ext]',
        outputPath: 'assets',
      },
    },
  ],
},
```

在配置中，limit 表示文件大小的阈值，如果文件大小小于该值，则将文件转换为 base64 格式并内联到代码中，否则使用 file-loader 进行处理。

1. image-webpack-loader

image-webpack-loader 可以优化图片文件，包括压缩、裁剪、缩放等操作，以减小文件大小，提高页面加载性能

## 7. 如何在 Webpack 中配置 DevServer？请说明 DevServer 的作用和配置方式

DevServer 是 Webpack 中一个独立的开发服务器，用于在开发过程中提供服务和监视文件变化。它可以实现自动刷新、热更新、代理等功能，方便开发人员进行开发和调试。

配置 DevServer 可以在 webpack.config.js 文件中添加 devServer 配置项，常用的配置选项有：

1. contentBase

指定服务器提供内容的根目录，默认为当前工作目录。可以设置为绝对路径或相对路径。

1. port

指定 DevServer 监听的端口号，默认为 8080。

1. hot

启用热更新功能，可以实现在不刷新页面的情况下更新模块。

1. proxy

设置代理，可以将请求转发到其他服务器或接口，用于解决跨域问题。

1. historyApiFallback

启用 HTML5 History API，可以解决单页面应用在路由切换时出现 404 的问题。

下面是一个简单的 DevServer 配置示例：

```js
javascriptCopy codeconst path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  devServer: {
    contentBase: path.resolve(__dirname, 'dist'),
    port: 9000,
    hot: true,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        pathRewrite: { '^/api': '' },
      },
    },
    historyApiFallback: true,
  },
};
```

在以上配置中，contentBase 指定了服务器提供内容的根目录为 dist 文件夹，port 指定了 DevServer 监听的端口号为 9000，hot 启用了热更新功能，proxy 设置了一个代理，将以 /api 开头的请求转发到 [http://localhost:3000，historyApiFallback](http://localhost:3000，historyApiFallback/) 启用了 HTML5 History API。

可以使用 `npm run serve` 命令启动 DevServer，也可以在配置文件中添加以下代码：

```js
javascriptCopy codedevServer: {
  // ...
},
plugins: [
  new webpack.HotModuleReplacementPlugin()
],
```

同时在 package.json 中添加如下命令：

```js
jsonCopy code{
  "scripts": {
    "start": "webpack serve --open",
  }
}
```

在终端输入 `npm start` 命令即可启动 DevServer。
