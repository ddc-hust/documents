## 项目开发日志

### 运行demo项目

- 今天要吧前端监控项目跑起来，监控的方法昨天已经大致看过了，虽然有很多细节不太明白，但是其实搞懂每一个细节，现在对我来说没有太大的意义，我觉得需要把项目跑起来，然后看一看关于如何使用sdk这个。
- 项目介绍说使用了pnpm+changesets来搭建monorepo架构的前端监控系统，pnpm是一个更快的包管理器，在npm上做了相应的改进，changesets是针对多包的，它可以准备的知道某个改动来自于哪一个包。**这里不是很理解多包。**是的，这个项目中反复提到了多包，包括monorepos也提到了多包，这个就是将多个包放在同一个仓库下进行管理。这个项目涉及到了多个包，比如分为核心模块、性能监测模块、页面录频模块，这些分为不同的包，放在同一个仓库下，可以支持用户选择自己想要的包进行安装。——这种多包的形式我之前没有接触到过，可以了解一下。
- 运行了demo项目，demo项目时可以正常运行的，demo项目中直接使用了web-see发布的包，然后用户点击的时候，可能是在项目中抛出错误，然后可以验证web-see的包，也就是接入的sdk是可以正常监测到错误的。先看一下如何在项目中抛出错误，然后接入sdk的方法。
- demo项目中用户抛出了错误，但是项目代码调用了getData函数，向http://localhost:8083/getErrorList请求了数据，然后就拿到了报错的数据。来分析一下是如何拿到报错的信息的

- - 首先用户触发了报错
  - 向这个getErrorList请求数据，那么这个接口的数据是从哪里来的，好像是使用了expree框架
  - 在main.js文件中，按照web-see的配置，配置了vue项目的上报地址，也就是http://localhost:8083/reportData，所以web-see这个sdk监测到错误后，会将错误的信息上报给这个接口
  - express搭建了静态服务器，拿到这个接口传来的数据后，会将数据存入数据库（这个demo项目中其实就是几个数组而已，比如errorList数组，performanceList数组等），
  - 然后由于express搭建了静态服务器，所以前端展示报错信息的table中，将会向express服务器请求错误数据，然后把错误信息展示出来。
  - 所以这个demo项目很好的展示了，web-see这个sdk是可以自动监测到用户触发的错误，然后把错误信息存入数据库中，然后从数据库中取错误信息，并且完整的展示出来了。
  - 很好，这个demo项目很好。后续自己也要做一个demo项目，可以是基于vue的，然后也使用express搭建静态服务器，然后插入自己的sdk，并让sdk将监测到的错误信息发送到自己搭建的静态服务器中，把错误信息存入数据后，在demo项目中展示出来。

- 现在需要去看一下，这个sdk项目是怎么做好的。sdk的插入是直接使用npm下载依赖，然后有一点基础的配置。而且针对不同的项目还有不同的配置方法。

### 性能数据的监测

* 走神了，赶紧看一下性能数据的监测要怎么弄，弄成SDK要发布的

* 创建项目，在项目下创建两个文件夹，pkg1和pkg2表示两个包（这样和sdk之后设计成核心模块和性能模块有关联，插件形式），使用pnpm init可以初始化项目。

* 但是项目中提到在npm上创建组织名，不知道这个是为什么？有什么用？

* 在pkg2中通过`import { pkg1 } from '@chuche-monitor/pkg1';`调用pkg1，最开始的时候是报错的，后来在pkg2中依赖了pkg1就没有报错了，执行了命令`pnpm install @chuche-monitor/pkg1 --filter @chuche-monitor/pkg2`后，pkg2的package.json中多出了`dependencies`依赖

  ```json
  "dependencies": {
      "@chuche-monitor/pkg1": "workspace:^"
    }
  ```

* 使用rollup工具进行打包。

* npm 包一般的版本结构为：`1.0.0`，类似这样的三位数版本号，分别是对应的 changeset version 里面的：`major`、`minor`、`patch`

* 使用changesets进行版本控制和管理。

* workspace协议：pnpm使用了workspace协议，packages下包含各种包，各种包之间可以相互引用。

* 在npm官网上可以创建组织，按照教程中的执行pnpm run changeset, pnpm publish等命令，就可以发包了

* 性能数据的监测很显然是一个插件，需要去看一下这个插件是怎么实现的。

  * 先创建一个performance文件夹，然后**执行pnpm init，进行初始化**

  * 创建src文件夹，创建index.ts作为入口文件，修改package.json中的name为组织名+包名

    ```json
    {
      "name": "@chuche-monitor/performance", // 组织名+包名
      "version": "1.0.0",
      "description": "",
      "main": "src/index.ts", // 入口文件
      "publishConfig": {
        "main": "dist/index.js",
        "access": "public"
      },
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "keywords": [],
      "author": "",
      "license": "ISC"
    }
    ```

* 性能数据的监控中，fp, fcp等指标数据的获取，是通过chrome团队提供的web-vitals库获取的。

  * 但是web-vitals不支持safari浏览器，对于safari浏览器，还是使用performance observer api来实现的。

* 在工程下，创建type文件夹，这个子项目专门用于存储类型的。

* 有用到typescript定义函数接口类型

  ```js
  export interface Callback { // 这里定义了一个函数类型，参数是任意数量任意类型的，返回值也是任意类型
      (...args: any[]): any;
  }
  ```

* **子工程之间存在依赖**，比如performance中需要用到type中的类型定义.可以使用

  ```js
  pnpm install @chuche-monitor/types --filter @chuche-monitor/performance
  ```

  * filter的意识是针对特定的包进行操作，也就是说在performance项目中安装types依赖，这样在performace的package.json文件中就存在对types子项目的依赖

  * ```js
    "dependencies": {
        "@chuche-monitor/types": "workspace:^"
    }
    ```

* **入口文件**：每个子项目都存在入口文件index.ts， 这个index.ts中将core文件夹下的东西导出供其它地方使用

* **插件的设计**：performance子项目作为一个插件，是要供外部使用的，所以performance子项目的入口文件index.ts中，需要实现一个类，并且这个类继承了baseplugin类，这样才可以作为插件使用

  * BasePlugin是一个类，有一个type属性，标识插件的类型——**需要去搞懂一下插件的类型有哪几种**，type属性标识的就是插件的类型，就是分为性能插件，用户行为插件，白屏插件等
  * 插件类有一个核心方法core，传入的参数是sdkBase
  * **packages**文件夹下都是各自独立的包，相当于各自独立的项目，每个项目都是设计好的插件，每个插件的src文件夹下，都是一个index.ts文件+core文件夹
  * **不同插件包之间创建依赖：**上上面的笔记，**需要注意的是需要去根目录下运行命令**
  * **common插件**：在common插件下，创建一个constant.ts文件，用于导出常量，**比如事件的类型，这里有些奇怪，事件的类型种类分的很细，有白屏、性能、行为、xhr、fetch、dom、vue、react等等**
  * 插件的core方法中，就是上报数据的地方，在core方法中，调用preformance中写好的获取性能数据的函数，传入一个回调函数，这个回调函数，在performance中会有写好的callback，并在performance的函数中，将获取到的性能数据作为参数传给这个回调函数callback，然后在性能插件的core方法中，就可以在参数中res获取到性能数据，那么在插件的core方法中要做的就是将数据上报出去，这里用到了transportData，不知道这个是干什么用的？不知道是怎么使用的
  * **transportData**方法中有用到获取时间戳函数getTimestamp，这个是在另外一个插件utils中使用的，在utils的helpers.ts中有这个函数的定义，通过使用Data.now就可以获取当前时间戳。
  * 到此，好像性能插件部分已经弄完了。到底是怎么使用的呢？


### 插件

* 有一个核心插件core, 然后性能插件、白屏插件、错误插件这种是独立开来的，先使用核心插件，如果要使用其它插件的话，就注册其它插件，通过chuche-monitor.use方法插入其它插件
* 这里好像不同框架使用插件的方式不一样，我这里其实是定义好了其它插件，然后希望可以将插件注入到项目中，就好像在vue框架中使用element-ui插件一样，他们都是一样的用法。**对于不同的框架，在框架中引入插件，我需要先在框架中引入核心插件，然后根据实际需要再引入其它功能的插件**
* 性能插件已经写好了，先去弄懂核心插件里面有什么？
* 核心core插件需要可以注册其它插件，所以核心插件中需要实现install函数
* **intall和use有啥区别？？**在react项目中使用了init函数，在vue项目中使用的是vue.use函数（不知道这个vue.use是否和这个install有关系？应该是没有关系的，install函数是用于注册其它插件使用的）
* **在install函数中有一个vue的flag的判断，不知道这个是干什么用的？**
* **事件类型eventtype中不知道为什么会有vue和react，这怎么会是事件类型呢？**
* **这个replaceType不知道是什么？，好像是事件类型**
* 在utils模块中的global和support不知道是干嘛的
* **作者自己定义了Window类型**，自己定义了websee，**设计到插件的发布订阅模式**，前面说的replaceFlag好像就是订阅事件用的，代码中就是订阅了vue事件
* **作者重写了vue项目的报错方式，在vue.config.errorHandle中报错**
* **项目中使用到了图片打点上报，不太清楚这个的作用**
* 上报数据reportData中继承了各种监控指标的类型的data,，然后又额外添加了一些共性要上报的指标。（在types模块下定义了不同指标上报的不同类型的数据）
* **数据上报的方式：优先使用sendBeacon 上报，若数据量大，再使用图片打点上报和fetch上报**
* **发布订阅模式在core模块中有定义**
* 现在的问题是需要将其它一些监控做成可插即用的方式，我可以先做性能检测和白屏检测，将这两个作为插件放进去。所以需要思考的问题是，怎么做到即插即用，core发包之后，如何做成可扩展的插件。好像是用到发布订阅模式，——**需要去看一下发布订阅模式是怎么弄的？**

### 发包

* pnpm run changeset	major\minor\xxx
* pnpm run packages-version
* pnpm run publish

### 测试

项目已经发包了，需要去测试一下是否可以正常使用，**在一个项目中，我是怎么注入到原项目中进行埋点的呢？这个需要去看一下，怎么弄的，**一个正常运行的项目，我想知道这个项目的性能，我需要对这个项目进行埋点，加载插件之后，这个数据是怎么检测到的，数据又是怎么上传的，应该不可以让用户自己去处理埋点，**埋点是自动的，这个应该怎么实现？**

* 先去创建一个项目，加载这个core插件，看看是否加载成功
* 去看一下web-see-demo项目中是如何使用插件的？web-see-demo项目中，引入web-see是引入的core包，并且只引入了core，性能，以及录频。**用户行为，接口监控这些是怎么使用的？为什么没有引入？**——我惊讶的发现只有性能和；录频是分出来的，也就是说，在这个插件中，用户行为以及一些其它的东西，都是集成到core中的，怪不得我直接写core的时候老是会遇到用户行为的代码。**那么白屏呢?白屏也是没有分出来的吗？**，使用vue.use就加载了这个core插件，然后呢？然后数据是怎么埋点的呢？
* 监控项目中也没有使用性能数据哎。**web-see当中到底是如何自动监控到错误，然后上报的？**，这个埋点的时机到底是怎么做的？监控项目中没有写多余的代码，感觉需要在web-see-core中去检查，应该是在包中埋得点。在包中，vue项目中会抛出错误，然后就会检测到，重写了vue得报错函数，然后就可以实现埋点了。**埋点应该就是这样，在加载插件的时候，执行vue.use的时候，会去执行包的install函数，应该在这里会有埋点函数的执行**
* **插件的埋点：**在vue项目被埋点的项目中，使用vue.use加载包，vue.use这个函数会自动执行包的install函数，于是在我们设计的主包core的install函数中，会去重写vue项目的报错，也就是在这里就会进行埋点，**需要去思考一下，这里的埋点什么时候执行，main.js什么时候执行，对于加载过程中的错误，是否会被检测到，这个是需要考虑的问题**。
* **为什么install函数中只有对vue报错的拦截，其它的东西不考虑吗？**；——好像考虑了，在init函数中有
* **自己设计插件的埋点**：在core包中如果想要加载其它可插可拔式的插件，可以通过在包core中的use函数中，去执行插件的core函数。是的，我的每个插件的核心都是一个core函数，如果想要加载这个插件，就需要去执行这个core函数，相当于core包的install函数。就是埋点的位置所在。
* 终于一整套流程弄通了。
* **明明安装的是chuche-monitor/core，为什么最后type, common, utils都安装了呢？或许是因为core中添加了对这个几个的依赖？？？**
* 在测试被监控项目vue2中出现包引用错误的问题，是因为自己的包有问题，好像需要有dist文件夹才可以，后面要看看build的操作。
* 流程打通了，引用包的问题，是因为需要构建包才可以，在根目录下，使用pnpm run build就可以，会在packages目录下的每个子项目中生成dist文件夹

### 打包

* 打包是通过rollup，rollup.config.js 会读取 packages 文件中各子目录的名称，并将每一个目录设置成打包的入口文件，并配置对应的出口路径

## 性能数据sdk

* 经过前面的操作，目前已经实现了自定义的插件，并且可以在项目中埋点使用了，而且可以扩展插件。就是需要去看一下这个插件是不是受限于框架的。——应该是不受限于框架的，执行init函数就可以。
* 目前基本的展示来不及做，先把sdk做出来再说。
* 性能数据的sdk做好了，可以获取到相应的数据，并且发包之后，就可以正常埋点了（**但是对于页面，不同页面会有不同的数据吗？还是只有一次数据？我认为对于单页面应用，是只有一次数据的，所以已经可以了**）
* 可以去做白屏异常了

## 白屏异常监测

* 采用采样对比+白屏修正的方案
* **采样对比：**
  
  * 从页面上选取17个采样点，判断这17个采样点所在的dom节点是否是容器元素。如果是容器元素，我们就认为这里是空白的。如果17个采样点所在的dom节点均是容器元素，则认为是白屏
  * （存在问题，就是可能在加载过程中dom节点还没有显示出来，不能认为就是白屏——针对这种情况，采用白屏修正方案）
* **白屏修正**：
  * 若初次判断是白屏的话，就启动轮询机制，**那什么时候上报白屏呢？**
    * 如果是网络不好，关键js资源或者接口数据没有返回，那么会出现阶段性的白屏。这个时候采用轮询机制，去判断空白点数是否是17，后面正常渲染之后，就不会是17了，就不会上报白屏
    * 但是如果是出现了Bug，应该上报白屏的时候，那么轮询机制总要有一个时间，这个时间应该以什么时候为准呢？
      * 代码中设置了浏览器的空闲时间，根据浏览器的空闲时间去判断是否执行采样函数。如果没有空闲时间，那么轮询机制下，其实并没有执行采样函数。**为了优化轮询带来的损耗，一直在执行采样，于是设置只有在有空闲时间的情况下采取执行轮询函数**。
      * 对于不支持空闲时间函数的浏览器，轮询函数中会默认执行采样函数，也就是说对于白屏异常的监控，是在后台一直挂着一个采样函数，**那就会一直采样，一直轮询，不久没有尽头了**。**现在的问题是，不是没有尽头，是会一直报白屏错误。对于正常情况，是先报白屏错误，然后报白屏正常，以最后的结果为准**，那么不管怎么弄，最后都要有一个时间的限制，可以设置多长时间呢？3秒吧——不是很合理
        * 可采用设置是在一定的轮询次数和时间截止条件下进行白屏监测——指标不治本
  
* **白屏采样的时机：**之前一直不知道到底是什么时候开始执行白屏采样的代码的？发现代码中有一个domcument.readyState的判断，不知道这个状态的更改，页面到底是处于什么时机下？——**文档的状态有加载中，可交互以及加载完成**。当document.readyState为complete的时候，就是html已经解析完毕，并且页面资源加载完毕，在这之后，再进行白屏异常的监控——**不过再web-see中，如果是骨架屏，就不会等到页面资源全部加载完毕了。

  * 白屏异常监测的时机应用到了**document.readyState为complete，当处于这个时机的时候，说明整个文档和它的子资源已经加载完毕，子资源指的是html文档引用的其它资源，比如图片、样式表以及脚本文件等。window.onload表示的是整个页面的所有资源都已经加载完毕，包括文档、子资源以及动态加载的资源**。动态加载的资源比如javascript动态加载的，或者是通过网络请求ajax动态获取的。如果处于网络不好的环境中，可能这些动态加载的资源还没加载完成，就已经到达了complete阶段，这个时候，页面可能会出现白屏。——对于这种情况，需要加载轮询机制。

* **简述白屏异常：**：去采样点，在页面上画一个十字，在横着上取9个采样点，把页面分成10等份。在竖线上取9个采样点，把页面分成10等份。通过document.elementsFromPoint函数可以获取指定坐标点所在的dom节点。判断这个17个采样所在的dom节点是否为容器节点，如果17个采样点所在的节点都是容器节点，就认为是白屏，就上报数据。但是考虑到可能由于资源的动态加载，由于网络原因导致资源返回的比较慢导致阶段的白屏，对于这种情况，我们加入轮询机制，如果17个采样点都是容器节点的话，就不停的继续采样，上报现象。对轮询加以轮询次数的限制以及轮询时间的限制。——**这个代码中没有加**

* 白屏异常的监测代码基本看完了，需要去看一下，这个白屏异常监测的代码是怎么嵌入到core中的。

* 在core下面有一个handleEvents文件，这个文件中，定义i了一个handleEvents对象，这个对象中有对白屏异常代码的加载。

* 对handleEvenets的调用，在setupReplace文件中有对应的代码。这个setupReplace好像是对什么东西进行了重写？？？

* 涉及到发布订阅模式了号线给，在core中，core中封装了一些核心的功能，这些功能好像也使用到了发布订阅模式。好像是当用户选择开启什么时间，就开启对应的事件。就是说当用户开启一个开关，就相当于发布，然后再插件中去开启对应的监测代码。

* 首先在setupReplace中有一个函数，叫做addReplaceHandler，这个函数中注入了白屏监测的代码。

  * 在replace.ts中有addReplaceHandler的具体实现，这个函数中，调用subscribeEvent函数，判断是否订阅了这个事件，如果没有直接返回，不然的话，调用replace函数，并传入事件的类型。

  * 在replace函数中，根据传入的事件类型，调用对应功能的replace函数，这里调用的是whitescreen函数，在这个函数中，调用了notify函数 ，notify函数中传入了对应的事件类型。

  * notify在subscribe.ts文件中有定义，这里每个事件都有对应的回调函数，白屏事件有对应的白屏监测的代码，http监测有对应的http监测的代码。所以在代码中，设置了handler，每个事件，都有对应的回调函数。当用户开启某个事件的时候，就相当于执行某个事件对应的回调函数。**但是这里发布订阅模式的体现在哪里呢？**，在notify中就是根据对应事件的名称，去执行了对应事件的回调函数。

    * 追溯到白屏监测代码最开始注入的地方，我知道了，subscribe订阅事件，相当于将事件的回调函数注入到handles中。notify通知事件，相当执行对应事件的的回调函数。最开始将白屏监测的代码，通过addReplaceHanled加入，然后，在这个函数中，会去调用subscritbe函数，将这个白屏监测的回调函数和事件进行了绑定。接着执行replace函数，调用notify函数，执行相应的这个事件的回调函数。
    * 不给自己设限，承担自己应该承担的风险，同时也要知道所走的每一步路都是后续的积淀，种花得花，种豆得豆，还是要脚踏实地。

  * **发布订阅模式：**发布订阅模式可以解耦发布者和订阅者之间的关系。提高扩展性，可以方便的添加订阅者，无需修改发布者的代码。

    * 在监控sdk中，由于有多种指标需要监控，比如监控js错误，监控http请求链路，监控白屏异常等。这些监控的指标可以作为订阅者，在发布者中代表的就是监控事件。sdk将事件作为消息发布，维护一个订阅者列表，订阅者就是不同事件对应的处理函数。
    * 使用时，用户可以选择是否开启某个指标的监控，如果开启了，在sdk中就相当于把这个事件作为消息发布了，然后可以去通知订阅者，从而执行这个指标对应的执行代码。
    * 这样以后如果要增加新的指标的监控的时候，不需要改动已有的代码，就可以实现，——可扩展性。

    

